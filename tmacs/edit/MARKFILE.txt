==============================
File-like interface to Markers
==============================

:Author: Ty Sarna
:Version: $Id: MARKFILE.txt,v 1.5 2007-08-22 23:03:03 tsarna Exp $

.. contents ::

Basics
------

The flush method of a marker does nothing as a buffer is already buffered::

    >>> from tmacs.edit.ubuf import marker, ubuf
    >>> u = ubuf("Hello World!\nHow are you?\n")
    >>> m = marker(u)
    >>> m.flush()


Positioning
-----------

The tell() method returns the current position within the buffer (the
same as `.start` or `len()`::

    >>> m.tell()
    0
    >>> m.start = 5
    >>> m.tell()
    5
    
The seek takes the same arguments with the same semantics as they do on
a file::

    >>> m.seek(3)
    >>> m.tell()
    3
    >>> m.seek(2, 1)
    >>> m.tell()
    5
    >>> m.seek(-3, 1)
    >>> m.tell()
    2
    >>> m.seek(0, 2)
    >>> m.tell()
    26
    >>> m.seek(-4, 2)
    >>> m.tell()
    22

Note that seek offsets are in terms of unicode characters, they aren't
guaranteed to be the same as when reading a real file.


Writing
-------

Writing is supported. Writing overwrites data if not at the end of the
file, and appends otherwise::

    >>> m.seek(0, 2)
    >>> m.write(u"Are you well?\n")
    >>> m.tell()
    40
    >>> u[:]
    u'Hello World!\nHow are you?\nAre you well?\n'
    >>> m.seek(-6, 1)
    >>> m.write("ok?\n")
    >>> m.tell()
    38
    >>> u[:]
    u'Hello World!\nHow are you?\nAre you ok?\n?\n'
    >>> m.write(u'Sure?\n')
    >>> m.tell()
    44
    >>> u[:]
    u'Hello World!\nHow are you?\nAre you ok?\nSure?\n'

The ``writelines`` method is also supported::

    >>> p = m.tell()
    >>> m.writelines([u'foo', u'bar', u'baz'])
    >>> m.tell() == len(u)
    True
    >>> u[:]
    u'Hello World!\nHow are you?\nAre you ok?\nSure?\nfoobarbaz'


Truncation
----------

The ``truncate()`` method is also implemented. Although Python allows
implementations to support "truncating a file longer", it doesn't seem
useful in this context so is not presently supported::

    >>> m.truncate(1000)
    Traceback (most recent call last):
       ...
    IndexError: can't extend buffer by truncation     

Nor is truncating to a negative size::

    >>> m.truncate(-42)
    Traceback (most recent call last):
       ...
    IndexError: can't truncate to negative size

Without an argument, the current position is used, or a specific
position may be specified::

    >>> m.seek(-6, 1)
    >>> m.truncate()
    >>> u[:]
    u'Hello World!\nHow are you?\nAre you ok?\nSure?\nfoo'
    >>> m.truncate(44)
    >>> u[:]
    u'Hello World!\nHow are you?\nAre you ok?\nSure?\n'
    >>> m.start
    44
    

Printing
--------

The softspace member is supported::

    >>> m.softspace
    0
    
Which means that the print statement may be used with a marker::

    >>> print >>m, u"Glad to hear it!\n"
    >>> m.tell()
    62
    >>> u[:]
    u'Hello World!\nHow are you?\nAre you ok?\nSure?\nGlad to hear it!\n\n'


Reading
-------

The `read()` method starts at the current location, reading the
specified number of characters and advancing the marker past them::

    >>> m.seek(2)
    >>> m.read(6)
    u'llo Wo'
    >>> m.read(4)
    u'rld!'

If there is not enough left in the buffer, less than the specificied
number of characters may be read::

    >>> m.read(1000)
    u'\nHow are you?\nAre you ok?\nSure?\nGlad to hear it!\n\n'
    
When the marker is at the end of the buffer, an empty string is read, as
is conventional for signaling EOF::

    >>> m.read(1)
    u''
    >>> m.read(10)
    u''
    >>> m.read()
    u''
        
In the last case, the size was omitted. This is equivalent to "read
until EOF", as we can see here:

    >>> m.seek(-5, 1)
    >>> m.read()
    u'it!\n\n'
    >>> m.read()
    u''

==================
Buffer-Gap Markers
==================

:Author: Ty Sarna
:Version: $Id: MARKER.txt,v 1.8 2007-08-17 15:47:31 tsarna Exp $

.. contents ::

Basics
------

Markers for the ``ubuf`` Unicode buffer-gap objects are provided by the 
``tmacs.edit.ubuf`` module::

    >>> from tmacs.edit.ubuf import marker, ubuf

A marker is only really useful when connected with a buffer. A marker
may be created linked to one::

    >>> b = ubuf(u"Hello World")
    >>> m = marker(b)
    >>> m.buffer is b
    True
    
or may be created separately then linked::

    >>> m2 = marker()
    >>> print m2.buffer
    None
    >>> m2.buffer = b
    >>> m2.buffer is b
    True
    
a buffer may be relinked to a different buffer as well, although this is
of limited usefulness::

    >>> b2 = ubuf()
    >>> m2.buffer = b2
    >>> m2.buffer is b
    False
    >>> m2.buffer is b2
    True

There is a weak-reference-like type of relationship between buffers and
markers. If a buffer is deleted, markers that were associated with it
become unlinked::

    >>> del b2
    >>> print m2.buffer
    None
    
likewise if a marker is deleted, the buffer will no longer reference it,
although the reference from the buffer side is not exposed::

    >>> del m


Marker Positions
----------------

The purpose of a marker is to indicate a position or range of positions
in a buffer. A marker may be initialized with start and end positions if
it is initialized with a buffer::

    >>> m = marker(b, 1, 4)
    >>> m.start, m.end
    (1, 4)

The positions may be set directly::

    >>> m.start = 2
    >>> m.start
    2

Negative numbers may be used, to count from the end, and out of range
numbers are silently clipped::

    >>> m.end = -5
    >>> m.end
    6
    >>> m.start = -100
    >>> m.start
    0
    >>> m.end = 400
    >>> m.end
    11
    
The end is always forced to be at or after the start::

    >>> m.start = 5
    >>> m.end = 2
    >>> m.end
    5
    >>> m.start = 7
    >>> m.end
    7

The len() of a marker is the number of characters spanned (end - start)::

    >>> m.end = 11
    >>> len(m)
    4
    

Numeric Operations
------------------

Spanning markers (where the start and end differ, spanning a range) are
only used for change tracking.  Many operations only consider the start
of a marker and ignore the end or reset it to be the same as the start. 
The start of a marker may be converted to an int or long, and may be
used direcly as a slice or subscript index::

    >>> int(m)
    7
    >>> long(m)
    7L
    >>> float(m)
    7.0
    >>> b[m]
    u'o'
    >>> b[:m]
    u'Hello W'
    >>> b[m:]
    u'orld'

Because a markers numeric value is always positive, abs() is equivalent
to int for markers, as is the unary + operator::

    >>> abs(m)
    7
    >>> +m
    7

The unary - operator also behaves as expected, returning a negative int::

    >>> -m
    -7
    
The inplace addition and subtraction operators may be use to move the
buffer forwards or backwards by a given amount. The marker is silently
constrained to the begining or end of the buffer, and the end is reset
to the resulting start::

    >>> m.start = 7
    >>> m.end = 11
    >>> m += 1
    >>> int(m)
    8
    >>> m.end
    8
    >>> m += -1
    >>> long(m)
    7L
    >>> m -= 1
    >>> float(m)
    6.0
    >>> m -= -1
    >>> int(m)
    7
    >>> m += 100
    >>> int(m)
    11
    >>> m -= 1000
    >>> int(m)
    0
    
In combination with other numeric types, a marker always coerces to
the other type::

    >>> m.start = 5
    >>> m - 1
    4
    >>> 1 + m
    6
    >>> 2.0 * m
    10.0
    >>> m * 0.5
    2.5
    >>> m / 1.0
    5.0
    >>> 10.0 / m
    2.0
    >>> 2L ** m
    32L
    >>> m // 2L
    2L

Only two numeric operations are allowed between a pair of markers, and
both return an int result.  Subtraction, for finding a difference in
position::

    >>> m2 = marker(m.buffer)
    >>> m2.start = 7
    >>> m2 - m
    2
    >>> m - m2
    -2

Addition is also supported for symmetry::

    >>> m + m2
    12
    >>> type(m+m2) is int, type(m-m2) is int
    (True, True)


Comparisons
-----------

Markers support comparison, based on the "start" value. Or to put it
another way, comparisons between markers are equivalent to comparison
between the int()-converted values of the markers.

    >>> m2 > m
    True
    >>> m2 >= m
    True
    >>> m2 == m
    False
    >>> m2 != m
    True
    >>> m > m2
    False
    >>> m >= m2
    False
    >>> m2.start = m
    >>> m > m2
    False
    >>> m >= m2
    True
    >>> m < m2
    False
    >>> m <= m2
    True
    
